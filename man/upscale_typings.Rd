% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/upscaling.R
\name{upscale_typings}
\alias{upscale_typings}
\title{Impute the resolution of an HLA typing from low to high (second field)}
\usage{
upscale_typings(
  filepath,
  typings,
  loci = c("A", "B", "DRB1", "DRB.", "DQB1"),
  population = "EURCAU",
  n_haplos = NULL,
  n_genos = 1,
  as_list = FALSE
)
}
\arguments{
\item{filepath}{String with the path to the \code{HLA-A~C~B~DRB1~DQB1.xlsx} file
as downloaded from \url{https://frequency.nmdp.org}.}

\item{typings}{String or character vector of HLA typings, with
space-separated alleles in serological notation.}

\item{loci}{Character vector of loci in the input genotype to be used for
upscaling. Must be a subset of \code{c("A", "B", "C", "DRB1", "DRB.", "DQB1")},
where \code{DRB.} is DRB3/4/5. If one of these loci does not occur in the input
typing, it will be ignored. N.B. this only controls the loci used for the
\emph{input} to the upscaling algorithm; the \emph{output} will always contain all of
them.}

\item{population}{String specifying which population group to use the
haplotype frequencies from. Must correspond to one of the abbreviations
that can be found on \url{https://haplostats.org}
Defaults to \code{"EURCAU"} (the largest population in the dataset).}

\item{n_haplos}{Number of most frequent haplotypes to use for the upscaling,
e.g. \code{5000} to consider only the 5000 haplotypes with the highest frequency
(the rest is discarded). Defaults to all haplotypes with a non-zero
frequency in the selected population.}

\item{n_genos}{Number of output genotypes to return for each input genotype,
sorted by probability (frequency) of the output genotypes. Defaults to the
most likely genotype only (i.e., \code{1}).}

\item{as_list}{Boolean (\code{TRUE} or \code{FALSE}) that determines whether to return
the result as a single dataframe, or a list of dataframes: one for each
input typing (the latter can be useful when the input typings also live in
a data frame; see examples).}
}
\value{
A (list of) dataframe(s) with the upscaling results, containing the
following columns:
\enumerate{
\item \code{id_input_typing}: Sequential identifier for the input typing
\item \code{id_unphased_geno}: Unique identifier for each output unphased genotype
\item \code{unphased_geno}: Upscaled genotype
\item \code{unphased_freq}: Frequency of upscaled genotype
\item \code{unphased_prob}: Probability of upscaled genotype
\item \code{phased_freq}: Frequency of phased genotype (= pair of haplotypes) that
make up the unphased genotype (can be many-to-one)
\item \code{phased_prob}: Probability of the phased genotype
\item \code{haplo_freq_1}: Frequency of the first haplotype in the phased genotype
\item \code{haplo_rank_1}: Rank (descending) of the frequency of this haplotype
\item \code{haplo_freq_2}: Frequency of the 2nd haplotype in the phased genotype
\item \code{haplo_rank_2}: Rank (descending) of the frequency of this haplotype
}
}
\description{
\code{upscale_typings()} takes in a (vector of) low-resolution HLA typing
string(s), and "upscales" it to(two-field) high resolution based on
\href{http://dx.doi.org/10.1016/j.humimm.2013.06.025}{haplotype frequencies from the NMDP registry}.
}
\details{
This function uses haplotype frequencies published by the NMDP at
\url{https://frequency.nmdp.org}. You'll need to login and accept the license to
obtain the data, which is why we cannot distribute it with this package.
\subsection{Imputation algorithm}{

Roughly, the function performs the following steps:
\enumerate{
\item Translate all haplotype alleles from high-resolution to their serological
equivalents
\item Select compatible haplotypes, i.e. those haplotypes with alleles that
\emph{all} occur in the input genotype
\item Combine all compatible haplotypes into phased genotypes (i.e. unique
haplotype pairs). Fully homozygous haplotypes are not considered
\item Calculate the frequency and probability of the phased genotypes
\item Combine phased genotypes into unique unphased genotypes, and calculate
their frequency and probability
}

For a detailed explanation of the terminology and imputation algorithm,
see the following references:
\itemize{
\item Geffard et. al., Easy-HLA: a validated web application suite to reveal the
full details of HLA typing, \emph{Bioinformatics, Volume 36, Issue 7}, April
2020, Pages 2157â€“2164, \url{https://doi.org/10.1093/bioinformatics/btz875}
\item Madbouly, A., Gragert, L., Freeman, J., Leahy, N., Gourraud, P.-.-A.,
Hollenbach, J.A., Kamoun, M., Fernandez-Vina, M. and Maiers, M. (2014),
Validation of statistical imputation of allele-level multilocus phased
genotypes from ambiguous HLA assignments. \emph{Tissue Antigens, 84}: 285-292.
\url{https://doi.org/10.1111/tan.12390}
}
}
}
\examples{
\dontrun{
upscale_typings(
  filepath = "~/Downloads/A~C~B~DRB3-4-5~DRB1~DQB1.xlsx",
  typing = "A24 A28 B35 B61 DR4 DR11"
)

# If your GL Strings are in a data frame with some ID'ing columns that you
# If you've got more than one typing to upscale, perhaps along with some
# ID'ing columns (e.g. patient ID), it's probably best to put them in a
# data frame and call `upscale_typings()` on your data frame:
library(tidyverse)

typing_df <- tibble(
  id = c("001", "002"),
  input_typings = c(
    "A24 A28 B35 B61 DR4 DR11",
    "A2 A3 B52 B35 Cw4 DR11 DR52 DQ3"
  )
)
typing_df |>
  mutate(geno_df = upscale_typings(
    "~/Downloads/A~C~B~DRB3-4-5~DRB1~DQB1.xlsx",
    input_typings,
    as_list = TRUE
  )) |>
  unnest(geno_df)
}
}
